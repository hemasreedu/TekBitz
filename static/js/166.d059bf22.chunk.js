"use strict";(self.webpackChunkmy_app=self.webpackChunkmy_app||[]).push([[166],{166:function(e,n,i){i.r(n),i.d(n,{default:function(){return t}});i(791);var a=i(184);function t(){return(0,a.jsx)("section",{className:"questions",children:(0,a.jsxs)("div",{className:"container",children:[(0,a.jsx)("div",{className:"Table",children:(0,a.jsxs)("div",{className:"sidebar",children:[(0,a.jsx)("h3",{children:"Javascript Interview questions 2022"}),(0,a.jsx)("nav",{children:(0,a.jsxs)("ul",{className:"nav",children:[(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#IsJSSync",title:"1. Is Javascript synchronous or asynchronous language ?",children:"1. Is Javascript synchronous or asynchronous language ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#hoist",title:"2. Explain hoisting in Javascript ?",children:"2. Explain hoisting in Javascript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#undefinednotdefined",title:"3. Explain difference between not-defined & undefined in JS ?",children:"3. Explain difference between not-defined & undefined in JS ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#thiskeyword",title:"4. Explain this keyword in Javascript ?",children:"4. Explain this keyword in Javascript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#lexicalenv",title:"5. Explain the term Lexical environment in Javascript ?",children:"5. Explain the term Lexical environment in Javascript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#variablesinjs",title:"6. Difference between let,const and var in JavaScript ?",children:"6. Difference between let,const and var in JavaScript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#closures",title:"7. Explain closures in JavaScript ?",children:"7. Explain closures in JavaScript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#callbackfuncs",title:"8. Explain callback functions in JavaScript ?",children:"8. Explain callback functions in JavaScript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#eventloop",title:"9. What is event loop in JavaScript ?",children:"9. What is event loop in JavaScript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#hocfuncs",title:"10. What are higher order functions in JavaScript ?",children:"10. What are higher order functions in JavaScript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#MRF",title:"11. Explain how Map,filter and reduce are used in JavaScript ?",children:"11. Explain how Map,filter and reduce are used in JavaScript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#Callapplybind",title:"12. Explain call, apply and bind in JavaScript ?",children:"12. Explain call, apply and bind in JavaScript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#shadowing",title:"13. What is shadowing in JavaScript ?",children:"13. What is shadowing in JavaScript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#debouncing",title:"14. What is debouncing in Javascript ?",children:"14. What is debouncing in Javascript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#throttle",title:"15. What is throttling in Javascript ?",children:"15. What is throttling in Javascript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#curry",title:"16. What is currying in Javascript ?",children:"16. What is currying in Javascript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#bubble",title:"17. Difference between Event bubbling and capturing in Javascript ?",children:"17. Difference between Event bubbling and capturing in Javascript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#prototypalinh",title:"18. What is prototypal inheritance in Javascript ?",children:"18. What is prototypal inheritance in Javascript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#storage",title:"19. Define local storage and session storage in Javascript ?",children:"19. Define local storage and session storage in Javascript ?"})}),(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#asyncdiffer",title:"20. Why is the use of async and defer attributes in Javascript ?",children:"20. Why is the use of async and defer attributes in Javascript ?"})})]})})]})}),(0,a.jsxs)("div",{className:"qstns",children:[(0,a.jsxs)("section",{id:"IsJSSync",children:[(0,a.jsx)("h4",{children:"1. Is Javascript synchronous or asynchronous language ?"}),(0,a.jsx)("p",{children:"Javascript is a synchronous single threaded language. Only one command will be executed at a time, which means it has only one execution context/call stack. Each execution context has two components. First component is called Memory component/Variable environment and second component is called Code component/Thread of execution. In memory component all the variables and functions will be declared as key and value pairs. In code component each command will be called from memory component and executed each at a time, for which it is called as synchronous single threaded language."})]}),(0,a.jsxs)("section",{id:"hoist",children:[(0,a.jsx)("h4",{children:"2. Explain hoisting in Javascript ?"}),(0,a.jsxs)("p",{children:["Accessing variables and functions even before initializing them is defined as hoisting. This happens because, in phase 1 of execution i.e., memory creation phase, memory is allocated to each and every variable and functions in global space even before the code starts executing.",(0,a.jsx)("br",{}),(0,a.jsx)("pre",{children:(0,a.jsxs)("code",{className:"JSblock",children:["\n    console.log(a);.\n    greet();\n    a = 10;\n    function greet() {\n        console.log('Hi, there..');\n    }"," ",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Output:"}),(0,a.jsx)("br",{}),"undefined ",(0,a.jsx)("br",{}),"Hi, there..`",(0,a.jsx)("br",{})]})})]})]}),(0,a.jsxs)("section",{id:"undefinednotdefined",children:[(0,a.jsx)("h4",{children:"3. Explain difference between not-defined & undefined in JS ?"}),(0,a.jsxs)("p",{children:["Not defined is an error which results when Javascript engine is not able to find the variable in memory which results in Reference error. Where as Undefined is special keyword in javascript. Undefined is assigned to variables during memory creation phase.",(0,a.jsxs)("pre",{children:[(0,a.jsx)("strong",{children:"Not-defined eg :"}),"  ",(0,a.jsx)("br",{}),"console.log(x) ",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Output:"}),"\xa0 ReferenceError: x is not defined ",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Undefined eg: "}),(0,a.jsx)("br",{}),"console.log(a) ",(0,a.jsx)("br",{}),"var a=10; ",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Output:"}),"\xa0 undefined"]})]})]}),(0,a.jsxs)("section",{id:"thiskeyword",children:[(0,a.jsx)("h4",{children:"4. Explain this keyword in Javascript ?"}),(0,a.jsxs)("p",{children:["This refers to the object on which we call our function. For ",(0,a.jsx)("strong",{children:" eg: obj1.printName()"}),", here the value of ",(0,a.jsx)("strong",{children:"this"})," inside printName function is ",(0,a.jsx)("strong",{children:"obj1"}),". If we call our function as it is",(0,a.jsx)("strong",{children:" eg: printName()"}),", then the value of ",(0,a.jsx)("strong",{children:"this"})," inside printName() points to global object which is ",(0,a.jsx)("strong",{children:"window"}),"."]})]}),(0,a.jsx)("section",{id:"",children:(0,a.jsx)("h4",{})}),(0,a.jsxs)("section",{id:"lexicalenv",children:[(0,a.jsx)("h4",{children:"5. Explain the term Lexical environment in Javascript ?"}),(0,a.jsx)("p",{children:"When executing any program, JS engine first searches for the scope of variable in its local memory and if its not found it then searches in the local memory of its parent which is defined as Lexical environment."})]}),(0,a.jsxs)("section",{id:"variablesinjs",children:[(0,a.jsx)("h4",{children:"6. Difference between let,const and var in JavaScript ?"}),(0,a.jsxs)("p",{children:["Variables can be declared in Javascript using any of these keywords var,let and const.",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Var     :"}),"   Users can re-declare variable using var and user can update var variable. Also, users can declare the 2 variables with the same name using the var keyword. And hoisting is possible for var variables. ",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"let     :"}),"   Let variables are block scoped. Users cannot re-declare the variable defined with the let keyword but can update it. User can declare with same name only in different blocks. And hoisting is not possible for let variables. ",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"const   :"}),"   const keyword has all the properties that are the same as the let keyword, except the user cannot update it. Also, at the time of declaration user has to initialize a const variable."]})]}),(0,a.jsxs)("section",{id:"closures",children:[(0,a.jsx)("h4",{children:"7. Explain closures in JavaScript ?"}),(0,a.jsxs)("p",{children:["Closure is defined as a combination of a function bundled together with its lexical environment. In other words, a closure gives you access to an outer function's scope from an inner function. In JS, closures are created every time a function is created, ie., at function creation time.",(0,a.jsxs)("pre",{children:[(0,a.jsxs)("code",{children:["function y() {  \n    let a = 10;\n    function x()\n    {\n    var b=10;\n    console.log(a,b)\n    }\n    x();\n    }\n    y();"," ",(0,a.jsx)("br",{})]}),"In above example, function x forms closure with variables of function y."]})]})]}),(0,a.jsxs)("section",{id:"callbackfuncs",children:[(0,a.jsx)("h4",{children:"8. Explain callback functions in JavaScript ?"}),(0,a.jsxs)("p",{children:["As we know in JavaScript functions can be passed to any other functions as parameters. This function which you pass into another function is known as call back function. Using callbacks, async tasks can be performed in JS. Eg: using setTimeOut()",(0,a.jsx)("pre",{children:(0,a.jsx)("code",{children:"\n//Higher order function\nfunction greet(name, callback)\n                {\n                console.log('Hi' + ' ' + name);\n                callback();\n                }\n\n// callback function\nfunction callMe(){\n                console.log('I am callback function');\n                }\n\n// passing function as an argument\ngreet('Shanwik', callMe);"})})]})]}),(0,a.jsxs)("section",{id:"eventloop",children:[(0,a.jsx)("h4",{children:"9. What is event loop in JavaScript ?"}),(0,a.jsx)("p",{children:"When the timer expires for call back functions, call back function is put in call back queue. Even loop keeps a check on call back queue and call stack. As soon as call stack is empty event loops sends callback function from call back queue to call stack and the flow continues."})]}),(0,a.jsxs)("section",{id:"hocfuncs",children:[(0,a.jsx)("h4",{children:"10. What are higher order functions in JavaScript ?"}),(0,a.jsxs)("p",{children:["In Javascript, functions can be assigned to variables in the same way that strings or arrays can. They can be passed into other functions as parameters or returned from them as well. A higher-order function(HOC) is a function that accepts functions as parameters and/or returns a function",(0,a.jsx)("pre",{children:(0,a.jsx)("code",{children:"\n//Higher order function\nfunction greet(name, callback)\n                {\n                console.log('Hi' + ' ' + name);\n                callback();\n                }\n\n// callback function\nfunction callMe(){\n                console.log('I am callback function');\n                }\n\n// passing function as an argument\ngreet('Shanwik', callMe);"})})]})]}),(0,a.jsxs)("section",{id:"MRF",children:[(0,a.jsx)("h4",{children:"11. Explain how Map,filter and reduce are used in JavaScript ?"}),(0,a.jsxs)("p",{children:["Map, filter and reduce are higher order functions which accept function as an argument.",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Map :"})," Map is used for creating a new array from an existing one, applying function to each of the elements in the array.",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Filter :"})," filter takes each element in an array and it applies a conditional statement against it. If this conditional returns true, the element gets pushed to the output array. If the condition returns false, the element does not get pushed to the output array.",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Reduce :"})," Reduce method reduces an array of values down to just one value. To get the output value, it runs a reducer function on each element of the array.",(0,a.jsx)("br",{})]})]}),(0,a.jsxs)("section",{id:"Callapplybind",children:[(0,a.jsx)("h4",{children:"12. Explain call, apply and bind in JavaScript ?"}),(0,a.jsxs)("p",{children:["Call, Apply and bind are used to pass different values of ",(0,a.jsx)("strong",{children:"this"})," to a function.",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Call  :"})," Call invokes the function and is applied on the object which is passed as parameter. Any additional arguments are passed seperated by comma.",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Apply :"})," Apply and call works in a same way, the only difference is additional parameters are passed as an array.",(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Bind :"}),"  Bind returns the function and the function can be executed later with the context of ",(0,a.jsx)("strong",{children:"this"})," that is provided",(0,a.jsx)("br",{})]})]}),(0,a.jsxs)("section",{id:"shadowing",children:[(0,a.jsx)("h4",{children:"13. What is shadowing in JavaScript ?"}),(0,a.jsxs)("p",{children:["Shadowing occurs when a variable declared in a certain scope (e.g. a local variable) has the same name as a variable in an outer scope (e.g. a global variable). When this happens, the outer variable is said to be shadowed by the inner variable. ",(0,a.jsx)("br",{}),"In JavaScript, variables can be shadowed in both the global and function scope. Global variables can be shadowed by function-scoped variables, and function-scoped variables can be shadowed by block-scoped variables declared with the let or const keyword.",(0,a.jsx)("pre",{children:(0,a.jsx)("code",{children:'\nvar x = "global";\nfunction foo(){\nlet x = "function";\n// here variable x is shadowing variable in outer scope.\n        }\n'})})]})]}),(0,a.jsxs)("section",{id:"debouncing",children:[(0,a.jsx)("h4",{children:"14. What is debouncing in Javascript ?"}),(0,a.jsx)("p",{children:"The debounce function is built to limit the number of times a function is called. The debounce function forces the original event/function to wait a certain amount of time before running again. It resets the timer to the specified delay, incase of timeout call the debounce function."})]}),(0,a.jsxs)("section",{id:"throttle",children:[(0,a.jsx)("h4",{children:"15. What is throttling in Javascript ?"}),(0,a.jsx)("p",{children:"Throttling or to throttle a function means to ensure that the function is called at most once in a specified time period (for instance, once every 10 seconds). It calls a function immediately after the first click and then calls a function only after a particular interval of time"})]}),(0,a.jsxs)("section",{id:"curry",children:[(0,a.jsx)("h4",{children:"16. What is currying in Javascript ?"}),(0,a.jsxs)("p",{children:["Currying is a function that takes one argument at a time and returns a new function expecting the next argument. Currying is when a function , instead of taking all arguments at one time , takes the first one and returns a new function, which takes the second one and returns a new function, which takes the third one, etc. until all arguments are completed.",(0,a.jsx)("pre",{children:(0,a.jsx)("code",{children:"\nfunction calculateVolume(length)\n{\n    return function (breadth)\n{\n    return function (height)\n{\n    return length * breadth * height;\n                }\n            }\n        }\nconsole.log(calculateVolume(4)(5)(6));"})})]})]}),(0,a.jsxs)("section",{id:"bubble",children:[(0,a.jsx)("h4",{children:"17. Difference between Event bubbling and capturing in Javascript ?"}),(0,a.jsx)("p",{children:"Event bubbling means event propagation is done from child element to parent elements in the DOM. whereas, in Event capturing event propagation is done from parent element to child elements in the DOM. By default event bubbling is applied."})]}),(0,a.jsxs)("section",{id:"prototypalinh",children:[(0,a.jsx)("h4",{children:"18. What is prototypal inheritance in Javascript ?"}),(0,a.jsx)("p",{children:"In JavaScript, an object can inherit properties of another object. The object from where the properties are inherited is called the prototype. When we try to access a property of an object, the property is not only searched in the object itself. It's also searched in the prototype of the object, in the prototype of the prototype, and so on , until a property is found that matches the name or the end of the prototype chain is reached"})]}),(0,a.jsxs)("section",{id:"storage",children:[(0,a.jsx)("h4",{children:"19. Define local storage and session storage in Javascript ?"}),(0,a.jsx)("p",{children:"With sessionStorage, the data is persisted only until the window or tab is closed. With localStorage, the data is persisted until the user manually clears the browser cache or until your web app clears the data. It is recommended to use local storage than session storage."})]}),(0,a.jsxs)("section",{id:"asyncdiffer    ",children:[(0,a.jsx)("h4",{children:"20. Why is the use of async and defer attributes in Javascript ?"}),(0,a.jsx)("p",{children:'Async and Defer are optional attributes for the HTML script src="..." tag. They instruct the browser to download the indicated file in the background at a low priority without interrupting the process of rendering the page in the browser. Async and Defer both load JavaScript asynchronously without render blocking, but async executes as soon as possible while defer runs in sequence toward the end of the loading process, just before the DOMContentLoaded event.'})]})]})]})})}}}]);
//# sourceMappingURL=166.d059bf22.chunk.js.map